// Code generated by http://github.com/gojuno/minimock (v3.4.2). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/vbulash/chat-server/internal/repository.ChatRepository -o chat_repository_minimock.go -n ChatRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	outermodel "github.com/vbulash/chat-server/internal/model"
	desc "github.com/vbulash/chat-server/pkg/chat_v2"
)

// ChatRepositoryMock implements repository.ChatRepository
type ChatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChange          func(ctx context.Context, id int64, request *desc.ChatInfo) (err error)
	inspectFuncChange   func(ctx context.Context, id int64, request *desc.ChatInfo)
	afterChangeCounter  uint64
	beforeChangeCounter uint64
	ChangeMock          mChatRepositoryMockChange

	funcCreateSend          func(ctx context.Context, request *desc.ChatInfo) (i1 int64, err error)
	inspectFuncCreateSend   func(ctx context.Context, request *desc.ChatInfo)
	afterCreateSendCounter  uint64
	beforeCreateSendCounter uint64
	CreateSendMock          mChatRepositoryMockCreateSend

	funcDelete          func(ctx context.Context, id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mChatRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (cp1 *outermodel.Chat, err error)
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mChatRepositoryMockGet
}

// NewChatRepositoryMock returns a mock for repository.ChatRepository
func NewChatRepositoryMock(t minimock.Tester) *ChatRepositoryMock {
	m := &ChatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangeMock = mChatRepositoryMockChange{mock: m}
	m.ChangeMock.callArgs = []*ChatRepositoryMockChangeParams{}

	m.CreateSendMock = mChatRepositoryMockCreateSend{mock: m}
	m.CreateSendMock.callArgs = []*ChatRepositoryMockCreateSendParams{}

	m.DeleteMock = mChatRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ChatRepositoryMockDeleteParams{}

	m.GetMock = mChatRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*ChatRepositoryMockGetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryMockChange struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockChangeExpectation
	expectations       []*ChatRepositoryMockChangeExpectation

	callArgs []*ChatRepositoryMockChangeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockChangeExpectation specifies expectation struct of the ChatRepository.Change
type ChatRepositoryMockChangeExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockChangeParams
	paramPtrs *ChatRepositoryMockChangeParamPtrs
	results   *ChatRepositoryMockChangeResults
	Counter   uint64
}

// ChatRepositoryMockChangeParams contains parameters of the ChatRepository.Change
type ChatRepositoryMockChangeParams struct {
	ctx     context.Context
	id      int64
	request *desc.ChatInfo
}

// ChatRepositoryMockChangeParamPtrs contains pointers to parameters of the ChatRepository.Change
type ChatRepositoryMockChangeParamPtrs struct {
	ctx     *context.Context
	id      *int64
	request **desc.ChatInfo
}

// ChatRepositoryMockChangeResults contains results of the ChatRepository.Change
type ChatRepositoryMockChangeResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChange *mChatRepositoryMockChange) Optional() *mChatRepositoryMockChange {
	mmChange.optional = true
	return mmChange
}

// Expect sets up expected params for ChatRepository.Change
func (mmChange *mChatRepositoryMockChange) Expect(ctx context.Context, id int64, request *desc.ChatInfo) *mChatRepositoryMockChange {
	if mmChange.mock.funcChange != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Set")
	}

	if mmChange.defaultExpectation == nil {
		mmChange.defaultExpectation = &ChatRepositoryMockChangeExpectation{}
	}

	if mmChange.defaultExpectation.paramPtrs != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by ExpectParams functions")
	}

	mmChange.defaultExpectation.params = &ChatRepositoryMockChangeParams{ctx, id, request}
	for _, e := range mmChange.expectations {
		if minimock.Equal(e.params, mmChange.defaultExpectation.params) {
			mmChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChange.defaultExpectation.params)
		}
	}

	return mmChange
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.Change
func (mmChange *mChatRepositoryMockChange) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockChange {
	if mmChange.mock.funcChange != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Set")
	}

	if mmChange.defaultExpectation == nil {
		mmChange.defaultExpectation = &ChatRepositoryMockChangeExpectation{}
	}

	if mmChange.defaultExpectation.params != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Expect")
	}

	if mmChange.defaultExpectation.paramPtrs == nil {
		mmChange.defaultExpectation.paramPtrs = &ChatRepositoryMockChangeParamPtrs{}
	}
	mmChange.defaultExpectation.paramPtrs.ctx = &ctx

	return mmChange
}

// ExpectIdParam2 sets up expected param id for ChatRepository.Change
func (mmChange *mChatRepositoryMockChange) ExpectIdParam2(id int64) *mChatRepositoryMockChange {
	if mmChange.mock.funcChange != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Set")
	}

	if mmChange.defaultExpectation == nil {
		mmChange.defaultExpectation = &ChatRepositoryMockChangeExpectation{}
	}

	if mmChange.defaultExpectation.params != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Expect")
	}

	if mmChange.defaultExpectation.paramPtrs == nil {
		mmChange.defaultExpectation.paramPtrs = &ChatRepositoryMockChangeParamPtrs{}
	}
	mmChange.defaultExpectation.paramPtrs.id = &id

	return mmChange
}

// ExpectRequestParam3 sets up expected param request for ChatRepository.Change
func (mmChange *mChatRepositoryMockChange) ExpectRequestParam3(request *desc.ChatInfo) *mChatRepositoryMockChange {
	if mmChange.mock.funcChange != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Set")
	}

	if mmChange.defaultExpectation == nil {
		mmChange.defaultExpectation = &ChatRepositoryMockChangeExpectation{}
	}

	if mmChange.defaultExpectation.params != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Expect")
	}

	if mmChange.defaultExpectation.paramPtrs == nil {
		mmChange.defaultExpectation.paramPtrs = &ChatRepositoryMockChangeParamPtrs{}
	}
	mmChange.defaultExpectation.paramPtrs.request = &request

	return mmChange
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.Change
func (mmChange *mChatRepositoryMockChange) Inspect(f func(ctx context.Context, id int64, request *desc.ChatInfo)) *mChatRepositoryMockChange {
	if mmChange.mock.inspectFuncChange != nil {
		mmChange.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.Change")
	}

	mmChange.mock.inspectFuncChange = f

	return mmChange
}

// Return sets up results that will be returned by ChatRepository.Change
func (mmChange *mChatRepositoryMockChange) Return(err error) *ChatRepositoryMock {
	if mmChange.mock.funcChange != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Set")
	}

	if mmChange.defaultExpectation == nil {
		mmChange.defaultExpectation = &ChatRepositoryMockChangeExpectation{mock: mmChange.mock}
	}
	mmChange.defaultExpectation.results = &ChatRepositoryMockChangeResults{err}
	return mmChange.mock
}

// Set uses given function f to mock the ChatRepository.Change method
func (mmChange *mChatRepositoryMockChange) Set(f func(ctx context.Context, id int64, request *desc.ChatInfo) (err error)) *ChatRepositoryMock {
	if mmChange.defaultExpectation != nil {
		mmChange.mock.t.Fatalf("Default expectation is already set for the ChatRepository.Change method")
	}

	if len(mmChange.expectations) > 0 {
		mmChange.mock.t.Fatalf("Some expectations are already set for the ChatRepository.Change method")
	}

	mmChange.mock.funcChange = f
	return mmChange.mock
}

// When sets expectation for the ChatRepository.Change which will trigger the result defined by the following
// Then helper
func (mmChange *mChatRepositoryMockChange) When(ctx context.Context, id int64, request *desc.ChatInfo) *ChatRepositoryMockChangeExpectation {
	if mmChange.mock.funcChange != nil {
		mmChange.mock.t.Fatalf("ChatRepositoryMock.Change mock is already set by Set")
	}

	expectation := &ChatRepositoryMockChangeExpectation{
		mock:   mmChange.mock,
		params: &ChatRepositoryMockChangeParams{ctx, id, request},
	}
	mmChange.expectations = append(mmChange.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.Change return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockChangeExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockChangeResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.Change should be invoked
func (mmChange *mChatRepositoryMockChange) Times(n uint64) *mChatRepositoryMockChange {
	if n == 0 {
		mmChange.mock.t.Fatalf("Times of ChatRepositoryMock.Change mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChange.expectedInvocations, n)
	return mmChange
}

func (mmChange *mChatRepositoryMockChange) invocationsDone() bool {
	if len(mmChange.expectations) == 0 && mmChange.defaultExpectation == nil && mmChange.mock.funcChange == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChange.mock.afterChangeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChange.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Change implements repository.ChatRepository
func (mmChange *ChatRepositoryMock) Change(ctx context.Context, id int64, request *desc.ChatInfo) (err error) {
	mm_atomic.AddUint64(&mmChange.beforeChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmChange.afterChangeCounter, 1)

	if mmChange.inspectFuncChange != nil {
		mmChange.inspectFuncChange(ctx, id, request)
	}

	mm_params := ChatRepositoryMockChangeParams{ctx, id, request}

	// Record call args
	mmChange.ChangeMock.mutex.Lock()
	mmChange.ChangeMock.callArgs = append(mmChange.ChangeMock.callArgs, &mm_params)
	mmChange.ChangeMock.mutex.Unlock()

	for _, e := range mmChange.ChangeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChange.ChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChange.ChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmChange.ChangeMock.defaultExpectation.params
		mm_want_ptrs := mmChange.ChangeMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockChangeParams{ctx, id, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChange.t.Errorf("ChatRepositoryMock.Change got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmChange.t.Errorf("ChatRepositoryMock.Change got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmChange.t.Errorf("ChatRepositoryMock.Change got unexpected parameter request, want: %#v, got: %#v%s\n", *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChange.t.Errorf("ChatRepositoryMock.Change got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChange.ChangeMock.defaultExpectation.results
		if mm_results == nil {
			mmChange.t.Fatal("No results are set for the ChatRepositoryMock.Change")
		}
		return (*mm_results).err
	}
	if mmChange.funcChange != nil {
		return mmChange.funcChange(ctx, id, request)
	}
	mmChange.t.Fatalf("Unexpected call to ChatRepositoryMock.Change. %v %v %v", ctx, id, request)
	return
}

// ChangeAfterCounter returns a count of finished ChatRepositoryMock.Change invocations
func (mmChange *ChatRepositoryMock) ChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChange.afterChangeCounter)
}

// ChangeBeforeCounter returns a count of ChatRepositoryMock.Change invocations
func (mmChange *ChatRepositoryMock) ChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChange.beforeChangeCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.Change.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChange *mChatRepositoryMockChange) Calls() []*ChatRepositoryMockChangeParams {
	mmChange.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockChangeParams, len(mmChange.callArgs))
	copy(argCopy, mmChange.callArgs)

	mmChange.mutex.RUnlock()

	return argCopy
}

// MinimockChangeDone returns true if the count of the Change invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockChangeDone() bool {
	if m.ChangeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChangeMock.invocationsDone()
}

// MinimockChangeInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockChangeInspect() {
	for _, e := range m.ChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.Change with params: %#v", *e.params)
		}
	}

	afterChangeCounter := mm_atomic.LoadUint64(&m.afterChangeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeMock.defaultExpectation != nil && afterChangeCounter < 1 {
		if m.ChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.Change")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.Change with params: %#v", *m.ChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChange != nil && afterChangeCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.Change")
	}

	if !m.ChangeMock.invocationsDone() && afterChangeCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.Change but found %d calls",
			mm_atomic.LoadUint64(&m.ChangeMock.expectedInvocations), afterChangeCounter)
	}
}

type mChatRepositoryMockCreateSend struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateSendExpectation
	expectations       []*ChatRepositoryMockCreateSendExpectation

	callArgs []*ChatRepositoryMockCreateSendParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockCreateSendExpectation specifies expectation struct of the ChatRepository.CreateSend
type ChatRepositoryMockCreateSendExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockCreateSendParams
	paramPtrs *ChatRepositoryMockCreateSendParamPtrs
	results   *ChatRepositoryMockCreateSendResults
	Counter   uint64
}

// ChatRepositoryMockCreateSendParams contains parameters of the ChatRepository.CreateSend
type ChatRepositoryMockCreateSendParams struct {
	ctx     context.Context
	request *desc.ChatInfo
}

// ChatRepositoryMockCreateSendParamPtrs contains pointers to parameters of the ChatRepository.CreateSend
type ChatRepositoryMockCreateSendParamPtrs struct {
	ctx     *context.Context
	request **desc.ChatInfo
}

// ChatRepositoryMockCreateSendResults contains results of the ChatRepository.CreateSend
type ChatRepositoryMockCreateSendResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateSend *mChatRepositoryMockCreateSend) Optional() *mChatRepositoryMockCreateSend {
	mmCreateSend.optional = true
	return mmCreateSend
}

// Expect sets up expected params for ChatRepository.CreateSend
func (mmCreateSend *mChatRepositoryMockCreateSend) Expect(ctx context.Context, request *desc.ChatInfo) *mChatRepositoryMockCreateSend {
	if mmCreateSend.mock.funcCreateSend != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by Set")
	}

	if mmCreateSend.defaultExpectation == nil {
		mmCreateSend.defaultExpectation = &ChatRepositoryMockCreateSendExpectation{}
	}

	if mmCreateSend.defaultExpectation.paramPtrs != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by ExpectParams functions")
	}

	mmCreateSend.defaultExpectation.params = &ChatRepositoryMockCreateSendParams{ctx, request}
	for _, e := range mmCreateSend.expectations {
		if minimock.Equal(e.params, mmCreateSend.defaultExpectation.params) {
			mmCreateSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSend.defaultExpectation.params)
		}
	}

	return mmCreateSend
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateSend
func (mmCreateSend *mChatRepositoryMockCreateSend) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateSend {
	if mmCreateSend.mock.funcCreateSend != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by Set")
	}

	if mmCreateSend.defaultExpectation == nil {
		mmCreateSend.defaultExpectation = &ChatRepositoryMockCreateSendExpectation{}
	}

	if mmCreateSend.defaultExpectation.params != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by Expect")
	}

	if mmCreateSend.defaultExpectation.paramPtrs == nil {
		mmCreateSend.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateSendParamPtrs{}
	}
	mmCreateSend.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateSend
}

// ExpectRequestParam2 sets up expected param request for ChatRepository.CreateSend
func (mmCreateSend *mChatRepositoryMockCreateSend) ExpectRequestParam2(request *desc.ChatInfo) *mChatRepositoryMockCreateSend {
	if mmCreateSend.mock.funcCreateSend != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by Set")
	}

	if mmCreateSend.defaultExpectation == nil {
		mmCreateSend.defaultExpectation = &ChatRepositoryMockCreateSendExpectation{}
	}

	if mmCreateSend.defaultExpectation.params != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by Expect")
	}

	if mmCreateSend.defaultExpectation.paramPtrs == nil {
		mmCreateSend.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateSendParamPtrs{}
	}
	mmCreateSend.defaultExpectation.paramPtrs.request = &request

	return mmCreateSend
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateSend
func (mmCreateSend *mChatRepositoryMockCreateSend) Inspect(f func(ctx context.Context, request *desc.ChatInfo)) *mChatRepositoryMockCreateSend {
	if mmCreateSend.mock.inspectFuncCreateSend != nil {
		mmCreateSend.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateSend")
	}

	mmCreateSend.mock.inspectFuncCreateSend = f

	return mmCreateSend
}

// Return sets up results that will be returned by ChatRepository.CreateSend
func (mmCreateSend *mChatRepositoryMockCreateSend) Return(i1 int64, err error) *ChatRepositoryMock {
	if mmCreateSend.mock.funcCreateSend != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by Set")
	}

	if mmCreateSend.defaultExpectation == nil {
		mmCreateSend.defaultExpectation = &ChatRepositoryMockCreateSendExpectation{mock: mmCreateSend.mock}
	}
	mmCreateSend.defaultExpectation.results = &ChatRepositoryMockCreateSendResults{i1, err}
	return mmCreateSend.mock
}

// Set uses given function f to mock the ChatRepository.CreateSend method
func (mmCreateSend *mChatRepositoryMockCreateSend) Set(f func(ctx context.Context, request *desc.ChatInfo) (i1 int64, err error)) *ChatRepositoryMock {
	if mmCreateSend.defaultExpectation != nil {
		mmCreateSend.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateSend method")
	}

	if len(mmCreateSend.expectations) > 0 {
		mmCreateSend.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateSend method")
	}

	mmCreateSend.mock.funcCreateSend = f
	return mmCreateSend.mock
}

// When sets expectation for the ChatRepository.CreateSend which will trigger the result defined by the following
// Then helper
func (mmCreateSend *mChatRepositoryMockCreateSend) When(ctx context.Context, request *desc.ChatInfo) *ChatRepositoryMockCreateSendExpectation {
	if mmCreateSend.mock.funcCreateSend != nil {
		mmCreateSend.mock.t.Fatalf("ChatRepositoryMock.CreateSend mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateSendExpectation{
		mock:   mmCreateSend.mock,
		params: &ChatRepositoryMockCreateSendParams{ctx, request},
	}
	mmCreateSend.expectations = append(mmCreateSend.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateSend return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateSendExpectation) Then(i1 int64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateSendResults{i1, err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateSend should be invoked
func (mmCreateSend *mChatRepositoryMockCreateSend) Times(n uint64) *mChatRepositoryMockCreateSend {
	if n == 0 {
		mmCreateSend.mock.t.Fatalf("Times of ChatRepositoryMock.CreateSend mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateSend.expectedInvocations, n)
	return mmCreateSend
}

func (mmCreateSend *mChatRepositoryMockCreateSend) invocationsDone() bool {
	if len(mmCreateSend.expectations) == 0 && mmCreateSend.defaultExpectation == nil && mmCreateSend.mock.funcCreateSend == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateSend.mock.afterCreateSendCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateSend.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateSend implements repository.ChatRepository
func (mmCreateSend *ChatRepositoryMock) CreateSend(ctx context.Context, request *desc.ChatInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateSend.beforeCreateSendCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSend.afterCreateSendCounter, 1)

	if mmCreateSend.inspectFuncCreateSend != nil {
		mmCreateSend.inspectFuncCreateSend(ctx, request)
	}

	mm_params := ChatRepositoryMockCreateSendParams{ctx, request}

	// Record call args
	mmCreateSend.CreateSendMock.mutex.Lock()
	mmCreateSend.CreateSendMock.callArgs = append(mmCreateSend.CreateSendMock.callArgs, &mm_params)
	mmCreateSend.CreateSendMock.mutex.Unlock()

	for _, e := range mmCreateSend.CreateSendMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateSend.CreateSendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSend.CreateSendMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSend.CreateSendMock.defaultExpectation.params
		mm_want_ptrs := mmCreateSend.CreateSendMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateSendParams{ctx, request}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateSend.t.Errorf("ChatRepositoryMock.CreateSend got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.request != nil && !minimock.Equal(*mm_want_ptrs.request, mm_got.request) {
				mmCreateSend.t.Errorf("ChatRepositoryMock.CreateSend got unexpected parameter request, want: %#v, got: %#v%s\n", *mm_want_ptrs.request, mm_got.request, minimock.Diff(*mm_want_ptrs.request, mm_got.request))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSend.t.Errorf("ChatRepositoryMock.CreateSend got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSend.CreateSendMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSend.t.Fatal("No results are set for the ChatRepositoryMock.CreateSend")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateSend.funcCreateSend != nil {
		return mmCreateSend.funcCreateSend(ctx, request)
	}
	mmCreateSend.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateSend. %v %v", ctx, request)
	return
}

// CreateSendAfterCounter returns a count of finished ChatRepositoryMock.CreateSend invocations
func (mmCreateSend *ChatRepositoryMock) CreateSendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSend.afterCreateSendCounter)
}

// CreateSendBeforeCounter returns a count of ChatRepositoryMock.CreateSend invocations
func (mmCreateSend *ChatRepositoryMock) CreateSendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSend.beforeCreateSendCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateSend.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSend *mChatRepositoryMockCreateSend) Calls() []*ChatRepositoryMockCreateSendParams {
	mmCreateSend.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateSendParams, len(mmCreateSend.callArgs))
	copy(argCopy, mmCreateSend.callArgs)

	mmCreateSend.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSendDone returns true if the count of the CreateSend invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateSendDone() bool {
	if m.CreateSendMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateSendMock.invocationsDone()
}

// MinimockCreateSendInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateSendInspect() {
	for _, e := range m.CreateSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateSend with params: %#v", *e.params)
		}
	}

	afterCreateSendCounter := mm_atomic.LoadUint64(&m.afterCreateSendCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSendMock.defaultExpectation != nil && afterCreateSendCounter < 1 {
		if m.CreateSendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.CreateSend")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateSend with params: %#v", *m.CreateSendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSend != nil && afterCreateSendCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.CreateSend")
	}

	if !m.CreateSendMock.invocationsDone() && afterCreateSendCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateSend but found %d calls",
			mm_atomic.LoadUint64(&m.CreateSendMock.expectedInvocations), afterCreateSendCounter)
	}
}

type mChatRepositoryMockDelete struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockDeleteExpectation
	expectations       []*ChatRepositoryMockDeleteExpectation

	callArgs []*ChatRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockDeleteExpectation specifies expectation struct of the ChatRepository.Delete
type ChatRepositoryMockDeleteExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockDeleteParams
	paramPtrs *ChatRepositoryMockDeleteParamPtrs
	results   *ChatRepositoryMockDeleteResults
	Counter   uint64
}

// ChatRepositoryMockDeleteParams contains parameters of the ChatRepository.Delete
type ChatRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// ChatRepositoryMockDeleteParamPtrs contains pointers to parameters of the ChatRepository.Delete
type ChatRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatRepositoryMockDeleteResults contains results of the ChatRepository.Delete
type ChatRepositoryMockDeleteResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mChatRepositoryMockDelete) Optional() *mChatRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) Expect(ctx context.Context, id int64) *mChatRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ChatRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) ExpectIdParam2(id int64) *mChatRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mChatRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ChatRepository.Delete
func (mmDelete *mChatRepositoryMockDelete) Return(err error) *ChatRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ChatRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the ChatRepository.Delete method
func (mmDelete *mChatRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *ChatRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ChatRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ChatRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ChatRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mChatRepositoryMockDelete) When(ctx context.Context, id int64) *ChatRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &ChatRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ChatRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.Delete return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockDeleteExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.Delete should be invoked
func (mmDelete *mChatRepositoryMockDelete) Times(n uint64) *mChatRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ChatRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mChatRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements repository.ChatRepository
func (mmDelete *ChatRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := ChatRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ChatRepositoryMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("ChatRepositoryMock.Delete got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ChatRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ChatRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to ChatRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished ChatRepositoryMock.Delete invocations
func (mmDelete *ChatRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ChatRepositoryMock.Delete invocations
func (mmDelete *ChatRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mChatRepositoryMockDelete) Calls() []*ChatRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mChatRepositoryMockGet struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockGetExpectation
	expectations       []*ChatRepositoryMockGetExpectation

	callArgs []*ChatRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepositoryMockGetExpectation specifies expectation struct of the ChatRepository.Get
type ChatRepositoryMockGetExpectation struct {
	mock      *ChatRepositoryMock
	params    *ChatRepositoryMockGetParams
	paramPtrs *ChatRepositoryMockGetParamPtrs
	results   *ChatRepositoryMockGetResults
	Counter   uint64
}

// ChatRepositoryMockGetParams contains parameters of the ChatRepository.Get
type ChatRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// ChatRepositoryMockGetParamPtrs contains pointers to parameters of the ChatRepository.Get
type ChatRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatRepositoryMockGetResults contains results of the ChatRepository.Get
type ChatRepositoryMockGetResults struct {
	cp1 *outermodel.Chat
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mChatRepositoryMockGet) Optional() *mChatRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for ChatRepository.Get
func (mmGet *mChatRepositoryMockGet) Expect(ctx context.Context, id int64) *mChatRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ChatRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &ChatRepositoryMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.Get
func (mmGet *mChatRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ChatRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ChatRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectIdParam2 sets up expected param id for ChatRepository.Get
func (mmGet *mChatRepositoryMockGet) ExpectIdParam2(id int64) *mChatRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ChatRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ChatRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.Get
func (mmGet *mChatRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mChatRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by ChatRepository.Get
func (mmGet *mChatRepositoryMockGet) Return(cp1 *outermodel.Chat, err error) *ChatRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ChatRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ChatRepositoryMockGetResults{cp1, err}
	return mmGet.mock
}

// Set uses given function f to mock the ChatRepository.Get method
func (mmGet *mChatRepositoryMockGet) Set(f func(ctx context.Context, id int64) (cp1 *outermodel.Chat, err error)) *ChatRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the ChatRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the ChatRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the ChatRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mChatRepositoryMockGet) When(ctx context.Context, id int64) *ChatRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ChatRepositoryMock.Get mock is already set by Set")
	}

	expectation := &ChatRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &ChatRepositoryMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.Get return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockGetExpectation) Then(cp1 *outermodel.Chat, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockGetResults{cp1, err}
	return e.mock
}

// Times sets number of times ChatRepository.Get should be invoked
func (mmGet *mChatRepositoryMockGet) Times(n uint64) *mChatRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of ChatRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	return mmGet
}

func (mmGet *mChatRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements repository.ChatRepository
func (mmGet *ChatRepositoryMock) Get(ctx context.Context, id int64) (cp1 *outermodel.Chat, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := ChatRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("ChatRepositoryMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("ChatRepositoryMock.Get got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ChatRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ChatRepositoryMock.Get")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to ChatRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished ChatRepositoryMock.Get invocations
func (mmGet *ChatRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ChatRepositoryMock.Get invocations
func (mmGet *ChatRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mChatRepositoryMockGet) Calls() []*ChatRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Error("Expected call to ChatRepositoryMock.Get")
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.Get but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), afterGetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangeInspect()

			m.MinimockCreateSendInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangeDone() &&
		m.MinimockCreateSendDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone()
}
